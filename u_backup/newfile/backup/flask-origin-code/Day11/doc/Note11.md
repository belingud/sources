### 数据库模型关系

- 1:1
  
  - 使用场景
    - 业务拆分
      - 对现有的表进行拆分
    - 对既有项目的扩充
      - 扩充项目增加字段，直接在现有表里面操作可能会产生错误添加一个表就可以避免
  - 实现
    - 通过外键实现
    
    - 外键被添加了唯一约束
    
      - ```python
        # 通过设置外键和唯一约束，从表中的数据也是唯一，从而实现一对一的关系
        g_foo = models.ForeignKey(User, unique=True)
        ```
  - 操作
    - 删除用户的时候，从表数据会被级联删除
    - 删除v从表数据的时候，用户不会受影响
  - 总结
    - 虽然一对一的关系，但是存在主次
    - 一定要有主从表
      - 谁创建的ForeignKey()，谁是次表
  - 级联数据获取
    - 主获取从，隐性属性
      
      - 默认是级联对象的名字
      
      - ```python
        # user是主表，vip是从表主表获取从表的数据
        vip = user.vip
        ```
      
        
        
    - 从获取主，显性属性
  - 删除控制
    - on_delete
      - CASECADE	默认动作，级联删除
      - PROTECT        保护模式，存在级联数据不允许删除，不存在则删除
      - SET
        - NULL
          - 允许为NULL
        - DEFAULT
          - 本身有默认值
        - XXX
          - 合法值
- 1：M
  - 和一对一基本一致
  - 数据获取
    - 主表获取从表
      - 从表_set
      - 是一个Manager的子类
        - 动态创建的
        - 类是在函数中定义的，父类是函数传递进来的参数
    - 从表获取主表是显性属性
- N:M
  - 表现出来是两个数据之间的多对多映射
  - ManyToManyField
    - 对原表没有影响
  - 它会额外生成一张关系表
    - 关系表中存储了两张关联表的id
  - 操作
    - 主表
      - 从表_set
    - 从表
      - 声明关系的字段
    - 关系表
      - 不需要人为干涉
    - 主表和从表的级联属性（获取对方的这个属性）是一样的
      - model.Manager
        - all
        - filter
        - exclude
      - 处理关系
        - add
        - remove
        - clear
    - 自动处理关系表中的内容



### Django迁移

- 生成迁移
  - 根据模型和数据库中的表映射关系去生成
  - 差量生成，会校验数据变更
- 执行迁移
  - 在执行前要去迁移记录中查询哪些迁移文件已经被执行过了
  - 执行迁移文件
  - 执行完迁移文件，记录迁移

### 先有模型还是先有表?

- db -> models
  - 配制好数据库连接信息
  - python manage.py inspectdb  >  models.py
- models -> db
  - 目前使用



### 环境转移

- 导出所有依赖
  - pip freeze > requirements.txt
- 安装所有依赖
  - pip install -r requirements.txt



### homework

- 练习模型操作
- 实现收藏功能
  - 电影
  - 用户
  - 用户收藏电影













