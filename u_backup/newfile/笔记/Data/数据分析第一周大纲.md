# ipython

魔法指令：

1. 计算算法时间

   - %time      %%time代码运行时间

   - %timeit       %%timeit 一段代码运行多次，查看时间

2. 帮助文档
   - help()
   - 指令？
3. 查看变量
   - who    查看当前所有变量
   - whos    查看当前所有变量的详细信息
   - who_ls    吧当前所有变量以一个列表返回
4. 运行linux命令
   - %    执行Linux命令行
   - ！   执行Windows cmd命令行



# numpy

1. 构造函数

   - `np.array(list)`
   - `np.ones()`/ `np.zeros()`/ `npp.full(shape, fill_value, dtype)`
     - dtype要使用numpy的数据类型：np.int8, np.float32
   - `np.eye(N, M, k)`：行列和偏移量
   - `np.linspace(start, stop, num)/ np.arange(start, stop, step)`
   - `np.random.randn(d0, d1, d2...)`/ `np.random.normal(loc, scale, size)`
   - `np.random.random(size)`/ `np.random.randint(low, high, size)`

2. nparray属性

   - size
   - shape
   - ndim
   - dtype

3. 索引

   - `array[loc1, loc2, loc3...]`

4. 切片

   - 行切片：`arr[loc1: loc2]`
   - 列切片：`arr[:, loc1, loc2]`
   - 高维切片：`arr[:, :, loc1, loc2]`

5. 变形

   - `arr.reshape(tuple)`：变形时，size必须相同

6. 级联

   - `np.concatenate((arr1, arr2...), axis=1)`
   - 注意：在级联的维度上，数据的个数必须一致
     - 横向级联`np.hstack((arr1, arr2...))`
     - 纵向级联`np.vstack((arr1, arr2...))`

7. 切分

   - `np.split(indicates_or_sections)`
     - 在切分的维度上，能整除，可以设置一个整数，表示按该整数整分
     - 设置一个列表[m, n]，表示在该维度上，按照0-m，m-n，n-进行切分
   - `np.hsplit()`、`np.vsplit()`横向切分，纵向切分

8. 副本

   - `copy()` 深拷贝

9. 聚合操作

   - numpy的聚合默认是以整个数组为单位，注意控制axis的维度

   - 普通聚合：`arr.sum`、`arr.mean()`、`std()`、`max()`、`min()`、`argmax()`、`argmin()`、`prod()`、`any()`、`all()`
   - 空值聚合：`np.nansum()`、`np.nanmean()`...

10. 矩阵操作

    - 普通加减法`arr1 + arr2`：对应位置运算
    - 矩阵乘法：`np.dot(arr1, arr2)`

11. 广播机制

    - 确实维度补1
    - 用已有值填充新值
    - 不是所有numpy对象都可以龚波，只通过一次变形，就可以得到相同形状的才满足条件

12. 排序

    - `np.sort()`、`arr.sort()`全部排序
    - `np.partation(arr, k)`部分排序，k取一个整数，正数取最小k个数，负数取最大k个数



# pandas



1. Series

   - 创建
     - 列表创建：创建的是副本
     - numpy.array创建：创建的是引用
     - 字典创建：字典的键变成索引
   - 索引
     - 使用列表：`s[index]`
     - 使用字典：`s[key]`
     - 使用Series方式【推荐】：`s.loc[key]`、`s.iloc[index]`
   - 切片
     - 使用索引标签切片，是一个左闭右闭区间`s[key1: key2]`
     - 使用隐式索引，是一个左闭右开区间`s.iloc[loc1: loc2]`
   - 基本概念
     - 属性：shape, size, index, values
     - 函数：`head()`, `tail()`, `isnull()`, `notnull()`
     - name属性：表示Series对象在DataFrame中的列标签
   - 运算
     - 索引对齐，如果不对齐，空值补充np.nan
     - `add()`, `sub()`, `mul()`, `dic()` 可以对空值进行额外的处理
     - 支持广播

2. DataFrame：Series的容器

   - 创建

     - `DdataFrame(data, index, columns)`

     - 使用字典，一般字典的值是一个数组，会成为DataFrame中的一列。也可以构造一个空的DataFrame，再分别赋值每一列

       ```python
       df = DataFrame()
       df['name'] = ['tom', 'jerry', 'lucy']
       ```

     - 从文件读取

       ```python
       pd.read_csv(step='\t', headers=[表头])
       pd.read_table()
       pd.read_excel()
       ```

   - 索引

     - 字典访问，得到的列
     - `.loc[index]`：访问行
     - `fg.loc9index, column`
     - 其他访问方式，都属于间接访问，只读不写
     - 隐式访问：`df.iloc[indexloc, columnloc]`

   - 运算

     - DataFrame和DataFrame运算，索引对齐，不对齐缺失数据补空值
     - DdataFrame和Series运算，需要注意运算方向：`add(axis=1)`、`sub()`
     - DataFrame和整数运算

   - 丢失值处理

     - NaN，表达方式`np.nan`，特点是和任何数运算都得`np.nan`
     - `np.nan`是一个`np.float32`类型，运算效率高，`None`是object类型，不能运算，需要处理成`np.nan`才能运算
     - pandas会自动把`None`类型，转换成`np.nan`类型
     - `fillnan()`
       - fill_value：填充的值
       - method：填充方式，不能喝fill_value一起使用。bfill， ffill
       - axis：空值方向，上下，左右
       - limit：空值填充次数
     - dropna(fill_value, how)
       - fill_value：填充元素
       - how：any/all，又一个空值就过滤一行/全部是空值才过滤

   - `drop(labels, axis)`

     - labels：要过滤的行或列标签
     - axis：空值方向，匹配过滤的标签



# 复杂pandas类型

多层级索引



1. 构造函数：
   1. `pd.Multindex.from_arrays()`
   2. `pd.Multindex.from_tuples()`
   3. `pd.Multindex.from_product()`

2. 索引
   1. 可以使用（level1index, level2index）来表达多级索引逻辑
   2. 访问行多级索引的行：`df.loc[level1_index, level2_index]`
   3. 访问行多级索引的列：`df[level1_index, level2_index]`
   4. 访问行多级索引的元素：`df.loc[(level1_index, level2_index), column]`
   5. 访问列多级索引的元素：`df.loc[index, (level1_column, level2_column)]`
3. 切片
   1. 访问：先把多级索引，变成以及索引，再进行切片操作
   2. 写入：借助隐式索引的方式，或者做`stack()`和`unstack()`变换，再切片



# 级联

1. `pd.concat(objs, axis, join, join_axes, ignore_index, keys)`
   1. objs：对象列表
   2. axis：级联方向
   3. join：inner和outer，交际和并集
   4. join_axes：指定索引进行级联，`left.index`左连接，`right.index`右连接，如果要自定义连接轴，使用`index([A, B])`
   5. ignore_index：重排索引（索引没有意义）
   6. keys：保留原索引，又要避免冲突，可以设置分区，变成多层级索引



# 合并

`pd.merge(left, right, left_on, right_on, left_index, right_index, on, suffxes, sort)`



1. left/right：只能使用两个表合并，分别指定两个表
2. left_on/right_on：当两个表中，需要参考的列标签不相同时，用来指定column
3. left_index/right_index：当某个表希望以行索引作为合并参考列时使用
4. on：两个表中有多列相同的列标签，可以使用on来指定哪一列，或者哪几列作为合并参考系
5. suffixes：用来指定相同的但是不参与合并参考的列标签的后缀，通常和on一起使用



合并的前提：

- 合并是参考列来进行的
- 如果两个表中，至少有一列数据满足一对一、一对多或多对多关系中的一种，就可以合并
- 合并参考列的内容应该是离散型，object型的数据。如果不是离散型，应该映射成离散型数据



# 数据处理

----

## 删除重复数据

1. 监测重复行`df.duplicated(keep='first/last')`
   1. first：保留第一个
   2. last：保留最后一个
2. 删除重复行`df.drop_duplicates(keep='first/last')`

## 映射

1. `replace()`替换数值

   1. to_replace：一个值、一个列表、一个字典（多只替换、列替换）
   2. value：一个值、一个列表
   3. inplace：是否修改原数据

2. `rename()`替换索引

   1. mapper：字典，key：查找的值，value：替换的值，同时替换行列
   2. index：字典，替换行
   3. columns：字典，替换列
   4. level：指定多级索引的层级

3. `map()`映射一列

   1. 字典：离散型数据

      - 键值对多  不影响

      - 键值对少   `dict.get(x, x)`

   2. lambda  简单逻辑

   3. 函数    复杂逻辑

## 异常值检测和过滤

1. 空值监测：`isnull().any(axis)`

2. 异常值监测：`(df > 3).any(axis)`
3. `df.drop(labels=异常值的索引)`
4. `df.description()`、`df.info()`、`df.dtypes`查看数据的信息

## 排序

`take()`方法

1. 随机排序：`take(np.random.permutation(10))`
2. 随机抽样：`take(np.random.randint(0,100, 5))`
3. `df.sort_values(labels)`根据某一列的值进行排序
4. `df.set_index(column_name)`把某一列数据设置为索引，然后进行绘图展示

## 数据分组

1. `groupby()`接收一个列标签，或列标签列表，表示根据哪一列或哪几列进行分组
   1. 作为分组的列最好是离散型数据，不要使用连续性数据
2. `groups`
   1. 用来查看分组情况，返回一个字典，字典里每一个键值对表示，该列的某一个内容：该内容对应的行索引
3. 聚合操作
   1. 通常会使用分组对象进行聚合处理`g = df.groupby(['item'])`
   2. `g.sum()`, `g.agg({'price': 'mean', 'weight': sum})`

## 高级聚合



1. `apply()`：返回一个分组Series，适合于原始表进行合并
2. `transform()`：返回一个不分组的Series，行索引于原始表对齐，适合与原始表做级联

# scipy

1. 傅里叶变换：fftpackage.fft2   ifft2  应用于铝箔操作
2. 图像处理：misc、ndimage
   1. misc
      - misc.face(gray=True)
      - misc.imrotate()
      - misc.imresize()
      - misc.imfillter()
   2. ndimage
      - ndimage.rotate()
      - ndimage.zoom()
      - ndimage.shift()
      - 高斯滤波
3. 数学运算：积分函数
   1. scipy.integrate.quad(func, a, b)
4. 文件处理：`scipy.io`
   1. io.savemat()
   2. io.loadmat()

# 绘图

两个包：

```python
matplotlib.pyplot as plt
%matplotlib inline
```





1. 画板
   1. 获取画板：`figure = plt.figure(figsize=(), facecolor=())`
   2. `figure.save(facecolor)`
2. 画布
   1. `axes = figure.add_subplot(111)`
   2. `axes = plt.subplot(111)`
3. 画布标题
   1. `axes.set_title()`分区控制
   2. `plt.title()`画布
4. 画布网格线
   1. `axes.grid(linewidth, color, alpha, axis)`
   2. `plt.grid()`
5. 坐标轴
   1. `axes.axis('off')`
   2. `axes.axis('equal, scale')`
6. 坐标轴标签
   1. `axes.set_xlabel(), axes.set_ylabel()`
   2. `plt.xlabel(fontdict = {}), plt.ylabel(fontsize, color, location)`
7. 坐标轴刻度
   1. `plt.xlim()`,`plt.ylim`上下边界
   2. `axes.set_xlim()`,`axes.set_ylim()`上下边界
   3. `axes.xticks([刻度列表], [标签列表])`, `axaes.yticks([刻度列表], [标签列表])`
   4. `axes.set_xticks()`, `axes.set_yticks()`
8. 坐标轴刻度标签
   1. `axes.set_xtickLabels()`, `axes.set_ytickLabels()`

9. 绘制曲线
   1. linewidth
   2. color
   3. linestyle
   4. dashes
   5. marker
   6. markersize
   7. markeredgecolor
   8. markerfacecolor
   9. markeredgewidth
10. 获取线对象
    1. `lines = plt.plot(x, y1, x, y2, x, y3)`，生成一个列表，然后分别设置线的属性
11. 图例：
    1. ncol：设置图例的列数
    2. loc：设置图例位置

```python
axes.plot(x, y, label='first')
axes.legend()

axes.plot(x, y, x, y1, x, y2)
axes.legend(['first', 'second', 'third'], ncol=2, loc=[0 ,1])
```

也可以通过plt

```python
plt.plot()
plt.legend()
```




