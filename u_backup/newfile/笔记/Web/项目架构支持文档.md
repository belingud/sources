### 公司的组织结构

- 股东
- 管理层
- 人力资源部
- 行政部
- 财务部
- 市场部
- 研发部
  - 产品
  - 技术
  - 运维
  - 测试
  - 数据分析

### 真实项目的开发流程

> 1.立项：立项会议，分析市场可行性，确认项目是否可行。
>
> 2.需求分析，确认项目目标一致，达成理解一致后，明确各自分工。
>
> 3.产品人团进行原型设计，提出详细开发需求。
>
> 4.分解需求，确定大概工期，分配阶段计划，迭代开发。
>
> 5.进入迭代周期：
>
> ​	1.确定本期详细的需求。
>
> ​	2.各技术人员分工开始工作。
>
> ​	3.前后端人员做接口设计，编写接口文档。
>
> ​	4.前后端各自开始开发各自的负责的需求。
>
> ​	5.前后端联合调试。
>
> ​	6.测试人员测试。
>
> ​	7.上线部署。
>
> ​	8.新功能发布。
>
> ​	9.对本次迭代做总结，开始下一次迭代需求讨论。
>
> ​	可参考的开发流程方式：
>
> ​		1、瀑布式：需求分析、设计、编码、测试、上线、完成。
>
> ​		2、Scrum：迭代开发。
>
> ​		3，kanban：看板看法，done，todo，doing。



###  RESTful 的概念, 前后端分离式的开发

- RESTful

  - 资源表现层状态装换
  - 一种网络软件架构风格，而非标准
  - 用URL定位资源
  - 用HTTP动词描述对资源的操作
    - GET：用来获取资源
    - POST：用来新建资源
    - PUT：用来更新资源
    - DELETE：用来删除资源

- 前后端分离：

  - 传统的Web开发，view函数中需要使用模板渲染，逻辑处理与显示的样式都需要后端开发。前后端分离后，显示效果完全由前端来实现，后端只需要传递前端需要的数据即可，这样前端的自由度变大，后端人员可以专心处理业务逻辑。
  - 优点：分工明确，提升开发效率

- 开发文档：

  - 前后端需要对接口的定义达成一致，在之后的开发过程中，不允许随意更改接口。

  - 详细定义每一个接口的各个部分：

    - 名称
    - 描述
    - 路径
    - 方法
    - 参数
    - 返回值

    

### 缓存的使用

- 为什么要使用缓存：

  - 对于Web应用来说，数据大多都需要动态加载，每次用户请求一个页面，Web服务器需要提供各种各样的计算--从业务逻辑到数据库查询到模板渲染--最后建立页面呈现给用户。对于中大型的网站来说，必须尽可能减少开销。
  - 缓存一些经过大量费时的计算结果，下次就不用再执行这些计算。

- 缓存的使用场景：

  - 对数据的实时性要求不高

- Django中缓存的使用

  - Django带有一个强大的缓存系统，提供了不用级别的缓存：缓存特定的视图，缓存难生成的内容，缓存整个网站。

- Memcached

  - 是一个完全基于内存的缓存服务器，是Django原生支持的最快、最高效、的缓存类型。Memcached以一个守护进程的形式运行，并且被分配了指定数量的RAM。它所做的就是提供一个快速接口用于在缓存中添加、检索和删除数据。所有数据都直接存储在内存中，因此不会产生数据库或文件系统使用的开销。
  - Django中使用Memcached
    - 安装Memcached
    - 安装一个Memcached绑定(python-memcached/pylibmc)
    - 修改CACHES-BACKEND和CACHES-LOCATION
    - 使用python-memcached绑定:
      - ![1565422440010](/home/hml/.config/Typora/typora-user-images/1565422440010.png)
    - Memcached可以在多个服务器上共享缓存，可以在多台计算机上运行，程序会视这组计算机为单个缓存。需要在CACHES-LOCATION中配置所有服务器的地址的列表就可以了。
    - 缺点：
      - 因为缓存的数据存储在内存中，如果服务器崩溃，数据会丢失。所以不适用于持久数据存储。

- django-redis

  - ```
    CACHES = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": "redis://127.0.0.1:6379/1",
            "OPTIONS": {
                "CLIENT_CLASS": "django_redis.client.DefaultClient",
            }
        }
    }
    ```

  - 可以添加修改更多配置为不用的场景配置不同的缓存空间和方式。

  - 在settings中添加配置，对全站进行缓存

  - ```
    MIDDLEWARE = [
        'django.middleware.cache.UpdateCacheMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',
    ]
    ```



###  Celery 异步任务处理

- Celery是一种任务队列

- 使用场景：

  - 解决异步任务，解决程序中的阻塞行为，如发邮件、大文件上传等。

- 基本结构：

  - 由程序动态产生异步任务，任务保存到任务队列(broker)，由worker取出并执行，将结果保存到backend中。

- Django + Celery + RabbitMQ

  - 在settings中添加配置

    - ```
      import djcelery
      djcelery.setup_loader()
      BROKER_URL= 'amqp://guest@localhost//'
      CELERY_RESULT_BACKEND = 'amqp://guest@localhost//'
      ```

    - 当djcelery.setup_loader()运行时，Celery会查看所有APP目录中的tasks.py文件，找到标记好的方法，将它们注册为celery task

    - BROKER_URL -- Broker的代理地址

    - CELERY_RESULT_BACKEND -- backend存储的地址。

- Django + Celery + Redis



### 日志的使用

- 日志可以帮助我们分析程序运行的状态和信息。
- Django中使用Python提供的logging模块来实现日志系统。
- 一份Python logging 配置由四部分组成:
  - Loggers
    - 是日志系统入口。每个logger都是命名了的bucket(存储空间)，消息写入bucket以进行下一步处理。
    - logger可以配置日志级别，日志级别描述了该logger处理的消息的严重性。
      - CRITICAL - 严重问题
      - ERROR - 大问题
      - WARNING - 警告
      - INFO - 通知
      - DEBUG - 调试
    - 每一条写入logger的消息都是一条日志记录。每一条日志记录也包含日志级别。代表对应消息的严重程度。
    - 当logger处理一条消息时，会将自己的日志级别和这条消息的日志级别做对比，当消息的级别大与logger时就会被进一步处理，否则就会忽略。
    - 当logger确定消息需要处理时，会把它传给Handler。
  - Handlers
    - Handler是决定如何处理logger中每一条消息的引擎。它描述特定的日志行为，比如把消息输出到屏幕、文件、或网络socket。
    - Handler也有日志级别的概念。如果一个日志的级别不匹配或低于handler的级别，就会忽略。
    - 一个logger可以有多个handler，每一个handler可以有不同的日志级别。这样就可以根据消息的重要性不同来提供不同格式的输出。
  - 过滤器
    - 在日志记录从logger传到handler的过程中，使用Filter来做额外的控制。
    - 可以增加额外条件，也可以降低日志级别等。
    - Filter在logger和handler中都可以添加，多个filter可以链接起来使用。
  - Formatters
    - 日志记录最终都需要以文本来呈现。Formatter描述了文本的格式。一个formatter通常由包含 LogRecord attributes 的Python格式化字符串组成。也可以自定义。
- 日志分析：
  - xxx



### Nginx 的配置, 及负载均衡

- Nginx是什么：
  - Nginx是一种Web服务器。基于REST架构风格，以统一资源定位符URL作为沟通依据，通过HTTP协议提供各种网络服务。
  - Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器，同时也是一个IMAP、POP3、SMTP代理服务器，Nginx可以作为一个HTTP服务器进行网站的发布处理，也可以作为反向代理进行负载均衡的实现。
- 优点：
  - Nginx使用基于事件驱动架构，使得其可以支持数百万级别的TCP连接。
  - 高度的模块化和自由软件许可证使得第三方模块层出不穷。
  - 是一个跨平台服务器，可以运行在多种操作系统上。
- Nginx也可以做反向代理。将客户端发送的请求传递到不同的服务器上。
- 负载均衡：
  - 客户端发送的、Nginx反向代理服务器接收到的请求数量，就是负载量。
  - 负载量按照一定的规则分发到不同的服务器进行处理的规则，就是均衡规则。
  - 将服务器接收到的请求按照规则分发的过程就是 - 负载均衡。
  - 负载均衡在实际项目操作中，有硬件负载均衡和软件负载均衡：
    - 硬件负载均衡：造价昂贵不考虑。
    - 软件负载均衡：结合现有的技术结合主机硬件实现的一种消息队列分发机制。
- Nginx支持的负载均衡调度算法：
  - 加权轮询：收到请求后按照权重分配到不用的后端服务器，给不同的服务器设置一个权重，权重越大，被分配的几率就越高。主要针对实际环境中后端服务器硬件配置来进行调整。
  - ip_hash：每个请求按照发起客户端的IP的hash结果进行匹配。这种算法下，一个固定的IP地址的客户端总会访问到同一个后端服务器。这也在一定程度上解决了集群部署下session共享问题。
  - fair：动态根据后端服务器的请求处理到响应的时间进行均衡分配，Nginx默认不支持fair算法，需要安装upstream_fair模块。
  - url_hash：根据访问的URL的hash结果进行分配，每个请求的URL会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。Nginx默认不支持，需要安装Nginx的hash软件包。



### 数据库优化、分布式数据库及数据分片。

- 数据库优化
  - 数据库结构优化：
    - 范式优化：表结构的设计合理化(3NF)，消除冗余。
    - 反范式优化：适当增加冗余，避免表关联查询。
    - 使用ID生成器代替自增主键
    - 避免不必要的外键约束
  - 优化SQL语句：
    - 使用索引来优化查询性能(把索引放在常用查询的字段上)。
    - 使用where子句代替having子句。
    - 定位慢查询语句，开始慢查询，设置慢查询时间，使用mysqldomoslow工具。
  - 分表分区：
    - 分表：把一个大表按照一定规则分解成多张具有独立存储空间的实体表。
    - 分区：将数据分段划分在多个位置存放。
  - 读写分离(主从数据库)：
    - 通过一个读写分离地址实现读写请求的自动转发。
    - 基本方式是让主数据处理写操作(insert、update、delete)，从数据库处理读操作(select)。数据库的一致性通过主从复制来实现。
  - 存储过程：
    - 存储过程是SQL语句和控制语句的与编辑集合，保存在数据库中，可由应用程序调用执行。
    - 优点：模块化程序设计，只需创建一次，就可以调用任意次，执行速度快，效率高，安全性高。



### 线上服务器的安装、部署

**Django + Nginx + uWSGI部署服务器**

- WSGI
  - Python服务器网关接口，是为Python语言定义的Web服务器和Web应用程序之间的一种简单通用的接口。WSGI是一种通信协议，由Web服务器(uWSGI等)和Web框架(Django等)去处理TCP连接、HTTP请求和响应等等，降低开发门槛，节约开发时间。
- uWSGI
  - 是一个实现了WSGI协议的服务器，它处理了HTTP的响应解析等，转成WSGI协议，这样我们编写的Web应用程序才可以对传递过来的信息进行处理。
- uwsgi
  - 是实现了WSGI协议的服务器的内部协议。定义了传输信息的类型，用于实现WSGI协议的服务器与其他网络服务器的数据通信。
- Nginx + uWSGI
  - Nginx接收到用客户端的请求，如果请求的是静态内容就直接返回静态内容，如果请求的是动态内容，就把请求转发给uWSGI，uWSGI连接Django进行处理。
- Supervisor
  - Supervisor是使用Python开发的一套通用的进程管理程序，是Linux/Unix系统下的进程管理工具，可以方便的监听、启动、停止、重启一个或多个进程。使用Supervisor管理的进程别意外的杀死或异常结束时，Supervisor会监听到并自动将它重启。



### 服务器架构

- 初期架构
  - Web应用程序、数据库、文件都部署在同一台服务器上。
- 服务拆分
  - Web应用、数据库、文件等服务分别部署到不同的服务器上。
- 利用缓存提升性能
  - 缓存
    - 本地缓存
      - 将数据缓存在应用服务器本地的内存或文件中。
    - 分布式缓存
      - 建立分布式缓存存储。
  - 动态转静态
    - 把请求量大但数据变动小的页面保存为静态页面。
- 应用服务器分布式部署（高并发）
  - 建立应用程序服务器集群
    - 分担请求量。
  - 部署负载均衡服务器
    - 调度请求，分发请求到应用程序服务器节点。
- 数据库读写分离
  - 主从数据库
    - 主数据库只进行写数据业务。
    - 从数据库只进行读数据业务。
    - 通过主从复制功能实现数据库同步。
- 数据库分表分库
  - 分表
    - 将数据库中特大表根据一定的方式进行切分
      - 增加数据表的数量。
      - 减少单个数据表的行数。
  - 分库
    - 根据业务模型分别建立数据库及服务器，根据业务切换查询
      - 建立数据库服务器集群。
      - 每个数据库服务器处理不同业务相关的数据。
- CDN、反向代理、云存储
  - CDN（内容分发网络）
    - 将一些缓存放在运营商的机房（阿里云、腾讯云、网宿等。）
    - 用户访问时先从最近的运营商获取数据。
  - 反向代理
    - 部署反向代理服务器，将数据缓存在反向代理服务器上
    - 如果请求的数据有缓存，则直接返回给用户。
- 分布式存储、云存储
  - 分布式存储
    - 建立分布式存储系统，保存用户上传的大量文件到不同的文件存储服务器上。
  - 云存储
    - 阿里云、腾讯云、七牛云。
- 搜索引擎和NoSQL
  - 解决海量文件的查询问题
    - 文件存放在分布式存储系统和服务器
    - 建立非关系型数据库存储相应的路劲和其他信息
    - 使用搜索引擎建立数据库的本地索引
  - 搜索引擎
    - lucene、whoosh
  - NoSQL
    - Redis、Mongodb
- 应用程序服务业务拆分和分布式服务
  - 应用程序服务器集群
    - 通过业务拆分，不同的应用服务器处理不用的业务
  - 分布式应用服务调度
    - 将各业务都需要的基本业务抽取出来，供所有应用使用
- 消息队列
  - 增加消息队列，异步化请求。



### 常用 Linux 命令, 以及初级 bash 脚本的开发

- 常用Linux命令：
  - https://www.jianshu.com/p/67466026c5be
- bash脚本
  - bash是Linux上标配的shell，能运行在大多数类Unix风格的操作系统上



### 爱鲜蜂项目技能总结

- 后端
  - 用户系统
    - 登录
    - 注册
    - 修改个人信息
    - 个人信息展示
    - 消息推送
  - 商品系统
    - 分类展示
    - 详细信息展示
    - 添加到购物车
    - 浏览记录
    - 收藏
  - 购物车系统
    - 购物车商品信息展示
    - 添加/减少/删除
    - 单选
    - 全选
    - 总价格计算
    - 购物车结算 + 优惠券选取
  - 订单系统
    - 订单生成
    - 订单结算
    - 订单分类展示(未付款/已付款/未收货/已收货)
    - 订单详细信息展示
  - 支付系统
    - 第三方支付集成
  - 收货地址管理
    - 地址信息展示
    - 添加/删除/修改地址
    - 修改默认地址
  - 评价系统
    - 评价信息展示
    - 商品评价
    - 商品追评
    - 信息回复
  - 积分系统
    - 积分获取
    - 积分兑换
  - 优惠系统
    - 商家发布优惠券
    - 开发商发布优惠券(积分兑换)

